import selene_sdk as s

# import torch as ch
# import tensorflow as tf

# my_data = [[1., -1.], [1., -1.]]
# print(ch.Tensor(my_data).shape)  # torch.Tensor
# print(tf.constant(my_data).shape)  # tensorflow.python.framework.ops.EagerTensor

# x = ch.Tensor([1.], requires_grad=True)
# with ch.no_grad():
# y = x * 2
# print(y.requires_grad)

# x = tf.Tensor([[1., -1.], [1., -1.]])
# tf.stop_gradient(x)
# print(x.get_shape())

# torch.arange()
# torch.autograd.Variable()
# torch.cat()
# torch.cuda.manual_seed_all()
# torch.from_numpy()
# torch.load()
# torch.manual_seed()
# torch.max()
# torch.nn._Loss()
# torch.nn.BatchNorm1d()
# torch.nn.BCELoss()
# torch.nn.Conv1d()
# torch.nn.DataParallel()
# torch.nn.Dropout()
# torch.nn.Linear()
# torch.nn.MaxPool1d()
# torch.nn.Module()
# torch.nn.ReLU()
# torch.nn.Sequential()
# torch.nn.Sigmoid()
# torch.no_grad()
# torch.optim.Optimizer()
# torch.optim.lr_scheduler.ReduceLROnPlateau()
# torch.optim.SGD
# torch.save()
# torch.set_num_threads()
# torch.squeeze()
# torch.Tensor()
# torch.utils.data.DataLoader()
# torch.utils.data.Dataset()
# torch.utils.data.sampler.SubsetRandomSampler()
