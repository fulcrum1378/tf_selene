# import selene_sdk as s

# s.EvaluateModel().evaluate()

# import torch as ch
# import tensorflow as tf
# my_data = [[1., -1.], [1., -1.]]
# print(ch.Tensor(my_data).shape)  # torch.Tensor
# print(tf.constant(my_data).shape)  # tensorflow.python.framework.ops.EagerTensor

# torch.arange()
# torch.autograd.Variable()
# torch.cat()
# torch.cuda.manual_seed_all()
# torch.from_numpy()
# torch.load()
# torch.manual_seed()
# torch.max()
# torch.nn._Loss()
# torch.nn.BatchNorm1d()
# torch.nn.BCELoss()
# torch.nn.Conv1d()
# torch.nn.DataParallel()
# torch.nn.Dropout()
# torch.nn.Linear()
# torch.nn.MaxPool1d()
# torch.nn.Module()
# torch.nn.ReLU()
# torch.nn.Sequential()
# torch.nn.Sigmoid()
# torch.no_grad()
# torch.optim.Optimizer()
# torch.optim.lr_scheduler.ReduceLROnPlateau()
# torch.optim.SGD
# torch.save()
# torch.set_num_threads()
# torch.squeeze()
# torch.Tensor()
# torch.utils.data.DataLoader()
# torch.utils.data.Dataset()
# torch.utils.data.sampler.SubsetRandomSampler()
