# torch.arange()                                   => tf.experimental.numpy.arange()
# torch.autograd.Variable()                        => tf.Variable()
# torch.cat()                                      =>
# torch.cuda.manual_seed_all()                     =>
# torch.from_numpy()                               =>
# torch.load()                                     =>
# torch.manual_seed()                              =>
# torch.max()                                      => tf.math.reduce_max()
# torch.nn._Loss()                                 =>
# torch.nn.BatchNorm1d()                           =>
# torch.nn.BCELoss()                               =>
# torch.nn.Conv1d()                                =>
# torch.nn.DataParallel()                          => REMOVED AND REPLACED BY tf.Module
# torch.nn.Dropout()                               =>
# torch.nn.Linear()                                =>
# torch.nn.MaxPool1d()                             =>
# torch.nn.Module()                                =>
# torch.nn.ReLU()                                  =>
# torch.nn.Sequential()                            =>
# torch.nn.Sigmoid()                               =>
# torch.no_grad()                                  => INSIDE tf.Variable() SET trainable=False
# torch.optim.Optimizer()                          =>
# torch.optim.lr_scheduler.ReduceLROnPlateau()     =>
# torch.optim.SGD                                  =>
# torch.save()                                     =>
# torch.set_num_threads()                          => tf.config.threading.set_intra_op_parallelism_threads()
# torch.squeeze()                                  => tf.squeeze()
# torch.Tensor()                                   => tf.Tensor() (created by tf.constant())
# torch.utils.data.DataLoader()                    =>
# torch.utils.data.Dataset()                       =>
# torch.utils.data.sampler.SubsetRandomSampler()   =>
